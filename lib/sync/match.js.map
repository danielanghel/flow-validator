{"version":3,"sources":["../../src/sync/match.js"],"names":["match","v","i","length","t","f","pv","parse","e","ValidationError","expected","name","got","description"],"mappings":";;;;;QA4HgBA,K,GAAAA,K;;AAzHhB;;AACA;;AAHA;;AA2HO,SAASA,KAAT,GAA4B;AACjC,MAAMC,oDAAN;AACA,OAAK,IAAIC,IAAI,CAAb,EAAgBA,IAAI,UAASC,MAA7B,EAAqCD,KAAK,CAA1C,EAA6C;AAC3C,QAAME,wBAA0BF,CAA1B,yBAA0BA,CAA1B,CAAN;AACA,QAAMG,wBAAuBH,IAAI,CAA3B,yBAAuBA,IAAI,CAA3B,CAAN;AACA,QAAII,WAAJ;AACA,QAAI;AACFA,WAAKF,EAAEG,KAAF,CAAQN,CAAR,CAAL;AACD,KAFD,CAEE,OAAOO,CAAP,EAAU;AACV,UAAIA,aAAaC,gCAAjB,EAAkC,SAAlC,KACK,MAAMD,CAAN;AACN;AACD,WAAOH,EAAEC,EAAF,CAAP;AACD;AACD,QAAM,IAAIG,gCAAJ,CAAoB;AACxBC,cAAW,EAAEC,MAAM,SAAR,EADa;AAExBC,SAAKX,CAFmB;AAGxBY,iBAAa;AAHW,GAApB,CAAN;AAKD","file":"match.js","sourcesContent":["// @flow\n/* eslint-disable no-redeclare */\n\nimport { ValidationError } from \"./ValidationError\";\nimport { Type } from \"./Type\";\n\ndeclare function match<A, AR, B, BR, C, CR, D, DR>(\n  v: A,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: C) => CR,\n  Type<D>,\n  (b: D) => DR\n): AR;\ndeclare function match<A, AR, B, BR, C, CR, D, DR>(\n  v: B,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: C) => CR,\n  Type<D>,\n  (b: D) => DR\n): BR;\ndeclare function match<A, AR, B, BR, C, CR, D, DR>(\n  v: C,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: C) => CR,\n  Type<D>,\n  (b: D) => DR\n): CR;\ndeclare function match<A, AR, B, BR, C, CR, D, DR>(\n  v: D,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: C) => CR,\n  Type<D>,\n  (b: D) => DR\n): DR;\ndeclare function match<A, AR, B, BR, C, CR, D, DR>(\n  v: mixed,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: C) => CR,\n  Type<D>,\n  (b: D) => DR\n): AR | BR | CR | DR;\n\ndeclare function match<A, AR, B, BR, C, CR>(\n  v: A,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: B) => CR\n): AR;\ndeclare function match<A, AR, B, BR, C, CR>(\n  v: B,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: B) => CR\n): BR;\ndeclare function match<A, AR, B, BR, C, CR>(\n  v: C,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: B) => CR\n): CR;\ndeclare function match<A, AR, B, BR, C, CR>(\n  v: mixed,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR,\n  Type<C>,\n  (b: B) => CR\n): AR | BR | CR;\n\ndeclare function match<A, AR, B, BR>(\n  v: A,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR\n): AR;\ndeclare function match<A, AR, B, BR>(\n  v: B,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR\n): BR;\ndeclare function match<A, AR, B, BR>(\n  v: mixed,\n  Type<A>,\n  (a: A) => AR,\n  Type<B>,\n  (b: B) => BR\n): AR | BR;\n\ndeclare function match<A, AR>(v: A, Type<A>, (a: A) => AR): AR;\ndeclare function match<A, AR>(v: mixed, Type<A>, (a: A) => AR): AR;\n\nexport function match(...patterns) {\n  const v: mixed = patterns[0];\n  for (let i = 1; i < patterns.length; i += 2) {\n    const t: Type<mixed> = patterns[i];\n    const f: Function = patterns[i + 1];\n    let pv;\n    try {\n      pv = t.parse(v);\n    } catch (e) {\n      if (e instanceof ValidationError) continue;\n      else throw e;\n    }\n    return f(pv);\n  }\n  throw new ValidationError({\n    expected: ({ name: \"pattern\" }: any),\n    got: v,\n    description: \"no pattern matches\"\n  });\n}\n"]}