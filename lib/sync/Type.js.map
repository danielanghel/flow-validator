{"version":3,"sources":["../../src/sync/Type.js"],"names":["Type","name","parse","transformation","tr","v","err","ValidationError","expected","got","description","refinement","rf","RefinedType","t2","ChainType","f","value","e","error","AsyncType","ArrayOfType","t","itemType","IntersectionType","a","b","typeA","typeB","UnionType","validate","OptionalType","innerType","MappingType","keys","values","ObjectType","schema","ObjectExactType","TupleType","left","right","base","ComposeLeftType","ComposeRightType"],"mappings":"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","file":"Type.js","sourcesContent":["// @flow\n\nimport { ValidationError } from \"./ValidationError\";\nimport { AsyncType } from \"../async/AsyncType\";\nimport { optional } from \"./optional\";\nimport { intersection } from \"./intersection\";\nimport { union } from \"./union\";\nimport { composeLeft } from \"./composeLeft\";\nimport { syncFunctionToAsync } from \"../async/syncFunctionToAsync\";\n\nexport class Type<T> {\n  name: string;\n  parse: (value: mixed) => T;\n  type: T;\n  constructor(name: string, parse: (value: mixed) => T) {\n    this.name = name;\n    this.parse = parse;\n  }\n  to<T2>(\n    transformation: (v: T, error: (e: string) => ValidationError) => T2\n  ): Type<T2> {\n    const tr = new Type(\"transformation\", v =>\n      transformation(\n        this.parse(v),\n        (err: string) =>\n          new ValidationError({ expected: tr, got: v, description: err })\n      )\n    );\n    return tr;\n  }\n  refine(\n    refinement: (v: T, error: (e: string) => ValidationError) => T\n  ): RefinedType<T> {\n    const rf = new RefinedType(this, v =>\n      refinement(\n        this.parse(v),\n        (err: string) =>\n          new ValidationError({ expected: rf, got: v, description: err })\n      )\n    );\n    return rf;\n  }\n  and<T2>(t2: Type<T2>): IntersectionType<T, T2> {\n    return intersection(this, t2);\n  }\n  or<T2>(t2: Type<T2>): UnionType<T, T2> {\n    return union(this, t2);\n  }\n  optional(): OptionalType<T> {\n    return optional(this);\n  }\n  chain<T2>(t2: Type<T2>): ChainType<T2> {\n    return new ChainType(this, t2);\n  }\n  compose<T2>(f: (v: T) => T2): ComposeLeftType<T, T2> {\n    return composeLeft(this, f);\n  }\n  parseResult(v: mixed): { value: T } | { error: ValidationError } {\n    try {\n      return { value: this.parse(v) };\n    } catch (e) {\n      if (e instanceof ValidationError) return { error: e };\n      throw e;\n    }\n  }\n  toJSON() {\n    return { name: this.name };\n  }\n  default(value: T): Type<T> {\n    // the default value to be used if supplied value is null or undefined\n    return new Type(\"default\", v => {\n      if (v === null || v === void null) return value;\n      return this.parse(v);\n    });\n  }\n  force(value: T): Type<T> {\n    // the default value is used if any validation error occurs\n    return new Type(\"default\", v => {\n      try {\n        return this.parse(v);\n      } catch (e) {\n        if (e instanceof ValidationError) return value;\n        throw e;\n      }\n    });\n  }\n  async(): AsyncType<T> {\n    return new AsyncType(this.name, syncFunctionToAsync(this.parse));\n  }\n}\n\nexport class ArrayOfType<T> extends Type<Array<T>> {\n  itemType: Type<T>;\n  constructor(t: Type<T>, parse: (value: mixed) => Array<T>) {\n    super(\"arrayOf\", parse);\n    this.itemType = t;\n  }\n}\n\nexport class IntersectionType<A, B> extends Type<A & B> {\n  typeA: Type<A>;\n  typeB: Type<B>;\n  constructor(a: Type<A>, b: Type<B>, parse: (value: mixed) => A & B) {\n    super(\"intersection\", parse);\n    this.typeA = a;\n    this.typeB = b;\n  }\n}\n\nexport class UnionType<A, B> extends Type<A | B> {\n  typeA: Type<A>;\n  typeB: Type<B>;\n  constructor(a: Type<A>, b: Type<B>, validate: (value: mixed) => A | B) {\n    super(\"union\", validate);\n    this.typeA = a;\n    this.typeB = b;\n  }\n}\n\nexport class OptionalType<T> extends Type<?T> {\n  innerType: Type<T>;\n  constructor(t: Type<T>, validate: (value: mixed) => ?T) {\n    super(\"optional\", validate);\n    this.innerType = t;\n  }\n}\n\nexport class MappingType<K, V> extends Type<{ [key: K]: V }> {\n  keys: Type<K>;\n  values: Type<V>;\n  constructor(\n    keys: Type<K>,\n    values: Type<V>,\n    parse: (value: mixed) => { [key: K]: V }\n  ) {\n    super(\"mapping\", parse);\n    this.keys = keys;\n    this.values = values;\n  }\n}\n\n// export type SchemaProps = {[key: string]: Type<any>};\n//export type SchemaType<P> = $ObjMap<P, <T>(v: Type<T>) => T>;\n\nexport class ObjectType<\n  S: { [key: string]: Type<any> },\n  T: $ObjMap<S, <F>(v: Type<F>) => F>\n> extends Type<T> {\n  schema: S;\n  constructor(schema: S, parse: (value: mixed) => T) {\n    super(\"object\", parse);\n    this.schema = schema;\n  }\n}\n\nexport class ObjectExactType<\n  S: { [key: string]: Type<any> },\n  T: $ObjMap<S, <F>(v: Type<F>) => F>\n> extends Type<T> {\n  schema: S;\n  constructor(schema: S, parse: (value: mixed) => T) {\n    super(\"objectExact\", parse);\n    this.schema = schema;\n  }\n}\n\n// export type TupleSchemaProps = Array<Type<any>>;\n// export type TupleSchemaType<P> = $TupleMap<P, <T>(v: Type<T>) => T>;\n\nexport class TupleType<T> extends Type<T> {\n  schema: Array<Type<any>>;\n  constructor(schema: Array<Type<any>>, parse: (value: mixed) => T) {\n    super(\"tuple\", parse);\n    this.schema = schema;\n  }\n}\n\nexport class ChainType<T> extends Type<T> {\n  left: Type<any>;\n  right: Type<T>;\n  constructor(left: Type<any>, right: Type<T>) {\n    super(\"compound\", v => right.parse(left.parse(v)));\n    this.left = left;\n    this.right = right;\n  }\n}\n\nexport class RefinedType<T> extends Type<T> {\n  base: Type<T>;\n  constructor(base: Type<T>, f: (v: mixed) => T) {\n    super(\"refined\", f);\n    this.base = base;\n  }\n  revalidate(): Type<T> {\n    return new Type(\"revalidated\", v => this.base.parse(this.parse(v)));\n  }\n}\n\nexport class ComposeLeftType<T, T2> extends Type<T2> {\n  left: Type<T>;\n  right: (v: T) => T2;\n  constructor(left: Type<T>, right: (v: T) => T2) {\n    super(\"composeLeft\", v => right(left.parse(v)));\n    this.left = left;\n    this.right = right;\n  }\n}\n\nexport class ComposeRightType<T, T2> extends Type<T2> {\n  left: (v: T) => T2;\n  right: Type<T>;\n  constructor(left: (v: T) => T2, right: Type<T>) {\n    super(\"compound\", v => left(right.parse(v)));\n    this.left = left;\n    this.right = right;\n  }\n}\n"]}