{"version":3,"sources":["../../src/async/asyncMapping.js"],"names":["asyncMapping","AsyncMappingType","keys","values","parse","AsyncType","m","v","objectType","o","validate","ks","result","errors","all","map","key","value","kv","vv","ke","ve","ValidationError","length","expected","got"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAoBgBA,Y,GAAAA,Y;;AAlBhB;;AACA;;AACA;;;;IAEaC,gB,WAAAA,gB;;;AAGX,4BACEC,IADF,EAEEC,MAFF,EAGEC,KAHF,EAIE;AAAA;;AAAA,0JACM,SADN,EACiBA,KADjB;;AAEA,UAAKF,IAAL,GAAYA,IAAZ;AACA,UAAKC,MAAL,GAAcA,MAAd;AAHA;AAID;;;EAXyCE,qB;;AAcrC,SAASL,YAAT,CACLE,IADK,EAELC,MAFK,EAGmB;AAAA;;AACxB,MAAMG,IAAI,IAAIL,gBAAJ,CAAqBC,IAArB,EAA2BC,MAA3B;AAAA,wFAAmC,kBAAMI,CAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,6BACjCC,gBADiC;AAAA;AAAA,qBACPD,CADO;;AAAA;AAAA;AACrCE,eADqC,gBACtBC,QADsB;AAErCC,gBAFqC,GAEhC,oBAAYF,CAAZ,CAFgC;AAGrCG,oBAHqC,GAG5B,EAH4B;AAIrCC,oBAJqC,GAI5B,EAJ4B;AAAA;AAAA,qBAKrC,kBAAQC,GAAR,CACJH,GAAGI,GAAH;AAAA,qGAAO,iBAAMC,GAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AACCC,+BADD,GACSR,EAAEO,GAAF,CADT;AAEDE,4BAFC;AAGDC,4BAHC;AAIDC,4BAJC;AAKDC,4BALC;AAAA;AAAA;AAAA,iCAOQnB,KAAKE,KAAL,CAAWY,GAAX,CAPR;;AAAA;AAOHE,4BAPG;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,gCASC,uBAAaI,gCATd;AAAA;AAAA;AAAA;;AAS+BF;AAT/B;AAAA;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA,iCAaQjB,OAAOC,KAAP,CAAaa,KAAb,CAbR;;AAAA;AAaHE,4BAbG;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,gCAeC,uBAAaG,gCAfd;AAAA;AAAA;AAAA;;AAe+BD;AAf/B;AAAA;;AAAA;AAAA;;AAAA;AAkBL,8BAAID,MAAMC,EAAV,EAAc;AACZR,mCAAOG,GAAP,IAAc,EAAEA,KAAKI,EAAP,EAAWH,OAAOI,EAAlB,EAAd;AACD,2BAFD,MAEO,IAAIH,EAAJ,EAAQN,OAAOM,EAAP,IAAaC,EAAb;;AApBV;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAP;;AAAA;AAAA;AAAA;AAAA,kBADI,CALqC;;AAAA;AAAA,mBA6BvC,mCAA2BN,MAA3B,EAAmCU,MA7BI;AAAA;AAAA;AAAA;;AAAA,oBA8BnC,IAAID,gCAAJ,CAAoB,EAAEE,UAAUlB,CAAZ,EAAemB,KAAKlB,CAApB,EAAuBM,cAAvB,EAApB,CA9BmC;;AAAA;AAAA,gDA+BpCD,MA/BoC;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAnC;;AAAA;AAAA;AAAA;AAAA,MAAV;AAiCA,SAAON,CAAP;AACD","file":"asyncMapping.js","sourcesContent":["// @flow\n\nimport { ValidationError } from \"../sync/ValidationError\";\nimport { AsyncType } from \"./AsyncType\";\nimport { objectType } from \"../sync/base\";\n\nexport class AsyncMappingType<K, V> extends AsyncType<{ [key: K]: V }> {\n  keys: AsyncType<K>;\n  values: AsyncType<V>;\n  constructor(\n    keys: AsyncType<K>,\n    values: AsyncType<V>,\n    parse: (value: mixed) => Promise<{ [key: K]: V }>\n  ) {\n    super(\"mapping\", parse);\n    this.keys = keys;\n    this.values = values;\n  }\n}\n\nexport function asyncMapping<K: string, V>(\n  keys: AsyncType<K>,\n  values: AsyncType<V>\n): AsyncMappingType<K, V> {\n  const m = new AsyncMappingType(keys, values, async v => {\n    const o = objectType.validate(await v);\n    const ks = Object.keys(o);\n    const result = {};\n    const errors = {};\n    await Promise.all(\n      ks.map(async key => {\n        const value = o[key];\n        let kv;\n        let vv;\n        let ke;\n        let ve;\n        try {\n          kv = await keys.parse(key);\n        } catch (e) {\n          if (e instanceof ValidationError) ke = e;\n          else throw e;\n        }\n        try {\n          vv = await values.parse(value);\n        } catch (e) {\n          if (e instanceof ValidationError) ve = e;\n          else throw e;\n        }\n        if (ke || ve) {\n          errors[key] = { key: ke, value: ve };\n        } else if (kv) result[kv] = vv;\n      })\n    );\n    if (Object.getOwnPropertyNames(errors).length)\n      throw new ValidationError({ expected: m, got: v, errors });\n    return result;\n  });\n  return m;\n}\n"]}