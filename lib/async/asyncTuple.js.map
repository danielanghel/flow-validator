{"version":3,"sources":["../../src/async/asyncTuple.js"],"names":["asyncTuple","asyncVtuple","AsyncTupleType","schema","parse","AsyncType","s","tt","v","arrayType","a","validate","errors","all","map","t","i","ValidationError","String","result","length","expected","got","AsyncVTupleType","AsyncVType","e"],"mappings":"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","file":"asyncTuple.js","sourcesContent":["// @flow\n\nimport { ValidationError } from \"../sync/ValidationError\";\nimport type { Errors } from \"../sync/ValidationError\";\nimport { AsyncType } from \"./AsyncType\";\nimport { AsyncVType } from \"./AsyncVType\";\nimport { arrayType } from \"../sync/arrayType\";\n\n/* eslint-disable no-redeclare */\n\nexport class AsyncTupleType<T> extends AsyncType<T> {\n  schema: Array<AsyncType<any>>;\n  constructor(\n    schema: Array<AsyncType<any>>,\n    parse: (value: mixed) => Promise<T>\n  ) {\n    super(\"tuple\", parse);\n    this.schema = schema;\n  }\n}\n\ndeclare function asyncTuple<A, B, C, D, E, F>(\n  types: [\n    AsyncType<A>,\n    AsyncType<B>,\n    AsyncType<C>,\n    AsyncType<D>,\n    AsyncType<E>,\n    AsyncType<F>\n  ]\n): AsyncTupleType<[A, B, C, D, E, F]>; // eslint-disable-line no-redeclare\ndeclare function asyncTuple<A, B, C, D, E>(\n  types: [AsyncType<A>, AsyncType<B>, AsyncType<C>, AsyncType<D>, AsyncType<E>]\n): AsyncTupleType<[A, B, C, D, E]>; // eslint-disable-line no-redeclare\ndeclare function asyncTuple<A, B, C, D>(\n  types: [AsyncType<A>, AsyncType<B>, AsyncType<C>, AsyncType<D>]\n): AsyncTupleType<[A, B, C, D]>; // eslint-disable-line no-redeclare\ndeclare function asyncTuple<A, B, C>(\n  types: [AsyncType<A>, AsyncType<B>, AsyncType<C>]\n): AsyncTupleType<[A, B, C]>; // eslint-disable-line no-redeclare\ndeclare function asyncTuple<A, B>(\n  types: [AsyncType<A>, AsyncType<B>]\n): AsyncTupleType<[A, B]>; // eslint-disable-line no-redeclare\ndeclare function asyncTuple<A>(types: [AsyncType<A>]): AsyncTupleType<[A]>; // eslint-disable-line no-redeclare\n\nexport function asyncTuple<S: Array<AsyncType<any>>>(\n  s: S\n): AsyncTupleType<$TupleMap<S, <T>(v: AsyncType<T>) => T>> {\n  // eslint-disable-line no-redeclare\n  const tt = new AsyncTupleType(s, async v => {\n    const a = arrayType.validate(await v);\n    const errors: Errors = {};\n    const result = await Promise.all(\n      s.map(async (t, i) => {\n        try {\n          return await t.parse(a[i]);\n        } catch (e) {\n          if (e instanceof ValidationError) {\n            errors[String(i)] = (e: ValidationError);\n            return (void 0: any);\n          } else throw e;\n        }\n      })\n    );\n    if (Object.getOwnPropertyNames(errors).length)\n      throw new ValidationError({ expected: tt, got: await a, errors });\n    return result;\n  });\n  return tt;\n}\n\nexport class AsyncVTupleType<T> extends AsyncVType<T> {\n  schema: Array<AsyncVType<any>>;\n  constructor(\n    schema: Array<AsyncVType<any>>,\n    parse: (value: mixed) => Promise<T>\n  ) {\n    super(\"tuple\", parse);\n    this.schema = schema;\n  }\n}\n\ndeclare function asyncVtuple<A, B, C, D, E, F>(\n  types: [\n    AsyncVType<A>,\n    AsyncVType<B>,\n    AsyncVType<C>,\n    AsyncVType<D>,\n    AsyncVType<E>,\n    AsyncVType<F>\n  ]\n): AsyncVTupleType<[A, B, C, D, E, F]>; // eslint-disable-line no-redeclare\ndeclare function asyncVtuple<A, B, C, D, E>(\n  types: [\n    AsyncVType<A>,\n    AsyncVType<B>,\n    AsyncVType<C>,\n    AsyncVType<D>,\n    AsyncVType<E>\n  ]\n): AsyncVTupleType<[A, B, C, D, E]>; // eslint-disable-line no-redeclare\ndeclare function asyncVtuple<A, B, C, D>(\n  types: [AsyncVType<A>, AsyncVType<B>, AsyncVType<C>, AsyncVType<D>]\n): AsyncVTupleType<[A, B, C, D]>; // eslint-disable-line no-redeclare\ndeclare function asyncVtuple<A, B, C>(\n  types: [AsyncVType<A>, AsyncVType<B>, AsyncVType<C>]\n): AsyncVTupleType<[A, B, C]>; // eslint-disable-line no-redeclare\ndeclare function asyncVtuple<A, B>(\n  types: [AsyncVType<A>, AsyncVType<B>]\n): AsyncVTupleType<[A, B]>; // eslint-disable-line no-redeclare\ndeclare function asyncVtuple<A>(types: [AsyncVType<A>]): AsyncVTupleType<[A]>; // eslint-disable-line no-redeclare\n\nexport function asyncVtuple<S: Array<AsyncVType<any>>>(\n  s: S\n): AsyncVTupleType<$TupleMap<S, <T>(v: AsyncType<T>) => T>> {\n  // eslint-disable-line no-redeclare\n  const tt = new AsyncVTupleType(s, async v => {\n    const a = arrayType.validate(await v);\n    const errors: Errors = {};\n    await Promise.all(\n      s.map((t, i) => {\n        try {\n          t.validate(a[i]);\n        } catch (e) {\n          if (e instanceof ValidationError)\n            errors[String(i)] = (e: ValidationError);\n          else throw e;\n        }\n      })\n    );\n    if (Object.getOwnPropertyNames(errors).length)\n      throw new ValidationError({ expected: tt, got: await a, errors });\n    return (a: any); // eslint-disable-line flowtype/no-weak-types\n  });\n  return tt;\n}\n"]}