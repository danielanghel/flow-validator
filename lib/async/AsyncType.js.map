{"version":3,"sources":["../../src/async/AsyncType.js"],"names":["AsyncType","name","parse","transformation","tr","v","vResolved","err","ValidationError","expected","got","description","refinement","rf","AsyncRefinedType","t2","AsyncChainType","f","AsyncComposeLeftType","resolve","then","base","AsyncIntersectionType","a","b","typeA","typeB","AsyncUnionType","validate","AsyncOptionalType","t","innerType","left","right"],"mappings":"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","file":"AsyncType.js","sourcesContent":["// @flow\n\nimport { ValidationError } from \"../sync/ValidationError\";\nimport { asyncUnion } from \"./asyncUnion\";\nimport { asyncIntersection } from \"./asyncIntersection\";\nimport { asyncOptional } from \"./asyncOptional\";\n\nexport class AsyncType<T> {\n  name: string;\n  parse: (value: mixed) => Promise<T>;\n  type: T;\n  constructor(name: string, parse: (value: mixed) => Promise<T>) {\n    this.name = name;\n    this.parse = parse;\n  }\n  to<T2>(\n    transformation: (\n      v: T,\n      error: (e: string) => ValidationError\n    ) => T2 | Promise<T2>\n  ): AsyncType<T2> {\n    const tr = new AsyncType(\"transformation\", async v => {\n      const vResolved = await v;\n      return transformation(\n        await this.parse(v),\n        (err: string) =>\n          new ValidationError({\n            expected: tr,\n            got: vResolved,\n            description: err\n          })\n      );\n    });\n    return tr;\n  }\n  refine(\n    refinement: (v: T, error: (e: string) => ValidationError) => Promise<T>\n  ): AsyncRefinedType<T> {\n    const rf = new AsyncRefinedType(this, async v =>\n      refinement(\n        await this.parse(v),\n        (err: string) =>\n          new ValidationError({ expected: rf, got: v, description: err })\n      )\n    );\n    return rf;\n  }\n  and<T2>(t2: AsyncType<T2>): AsyncIntersectionType<T, T2> {\n    return asyncIntersection(this, t2);\n  }\n  or<T2>(t2: AsyncType<T2>): AsyncUnionType<T, T2> {\n    return asyncUnion(this, t2);\n  }\n  optional(): AsyncOptionalType<T> {\n    return asyncOptional(this);\n  }\n  chain<T2>(t2: AsyncType<T2>): AsyncChainType<T2> {\n    return new AsyncChainType(this, t2);\n  }\n  compose<T2>(f: (v: T) => T2 | Promise<T2>): AsyncComposeLeftType<T, T2> {\n    return new AsyncComposeLeftType(this, (v: T) => Promise.resolve(v).then(f));\n  }\n  toJSON() {\n    return { name: this.name };\n  }\n}\n\nexport class AsyncRefinedType<T> extends AsyncType<T> {\n  base: AsyncType<T>;\n  constructor(base: AsyncType<T>, f: (v: mixed) => Promise<T>) {\n    super(\"refined\", f);\n    this.base = base;\n  }\n  revalidate(): AsyncType<T> {\n    return new AsyncType(\"revalidated\", async v =>\n      this.base.parse(await this.parse(v))\n    );\n  }\n}\n\nexport class AsyncIntersectionType<A, B> extends AsyncType<A & B> {\n  typeA: AsyncType<A>;\n  typeB: AsyncType<B>;\n  constructor(\n    a: AsyncType<A>,\n    b: AsyncType<B>,\n    parse: (value: mixed) => Promise<A & B>\n  ) {\n    super(\"intersection\", parse);\n    this.typeA = a;\n    this.typeB = b;\n  }\n}\n\nexport class AsyncUnionType<A, B> extends AsyncType<A | B> {\n  typeA: AsyncType<A>;\n  typeB: AsyncType<B>;\n  constructor(\n    a: AsyncType<A>,\n    b: AsyncType<B>,\n    validate: (value: mixed) => Promise<A | B>\n  ) {\n    super(\"union\", validate);\n    this.typeA = a;\n    this.typeB = b;\n  }\n}\n\nexport class AsyncOptionalType<T> extends AsyncType<?T> {\n  innerType: AsyncType<T>;\n  constructor(t: AsyncType<T>, validate: (value: mixed) => Promise<?T>) {\n    super(\"optional\", validate);\n    this.innerType = t;\n  }\n}\n\nexport class AsyncChainType<T> extends AsyncType<T> {\n  left: AsyncType<any>;\n  right: AsyncType<T>;\n  constructor(left: AsyncType<any>, right: AsyncType<T>) {\n    super(\"compound\", async v => right.parse(await left.parse(v)));\n    this.left = left;\n    this.right = right;\n  }\n}\n\nexport class AsyncComposeLeftType<T, T2> extends AsyncType<T2> {\n  left: AsyncType<T>;\n  right: (v: T) => Promise<T2>;\n  constructor(left: AsyncType<T>, right: (v: T) => Promise<T2>) {\n    super(\"composeLeft\", async v => right(await left.parse(v)));\n    this.left = left;\n    this.right = right;\n  }\n}\n"]}