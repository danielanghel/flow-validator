{"version":3,"sources":["../../src/async/asyncArrayOf.js"],"names":["asyncArrayOf","AsyncArrayOfType","t","parse","innerType","AsyncType","aof","v","a","arrayType","validate","errors","all","map","item","index","ValidationError","String","result","length","expected","got"],"mappings":";;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;QAegBA,Y,GAAAA,Y;;AAbhB;;AAEA;;AACA;;;;IAEaC,gB,WAAAA,gB;;;AAEX,4BAAYC,CAAZ,EAA6BC,KAA7B,EAAyE;AAAA;;AAAA,0JACjE,SADiE,EACtDA,KADsD;;AAEvE,UAAKC,SAAL,GAAiBF,CAAjB;AAFuE;AAGxE;;;EALsCG,qB;;AAQlC,SAASL,YAAT,CAAyBE,CAAzB,EAA+D;AAAA;;AACpE,MAAMI,MAAM,IAAIL,gBAAJ,CAAqBC,CAArB;AAAA,wFAAwB,kBAAMK,CAAN;AAAA;AAAA;AAAA;AAAA;AAAA;AAC5BC,eAD4B,GACxBC,qBAAUC,QAAV,CAAmBH,CAAnB,CADwB;AAE5BI,oBAF4B,GAEX,EAFW;AAAA;AAAA,qBAGH,kBAAQC,GAAR,CAC7BJ,EAAEK,GAAF;AAAA,qGAAM,iBAAOC,IAAP,EAAaC,KAAb;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iCAEWb,EAAEC,KAAF,CAAQW,IAAR,CAFX;;AAAA;AAAA;;AAAA;AAAA;AAAA;;AAAA,gCAIE,uBAAaE,gCAJf;AAAA;AAAA;AAAA;;AAKAL,iCAAOM,OAAOF,KAAP,CAAP;AALA,2DAMQ,KAAK,CANb;;AAAA;AAAA;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,iBAAN;;AAAA;AAAA;AAAA;AAAA,kBAD6B,CAHG;;AAAA;AAG5BG,oBAH4B;;AAAA,mBAe9B,mCAA2BP,MAA3B,EAAmCQ,MAfL;AAAA;AAAA;AAAA;;AAAA,oBAgB1B,IAAIH,gCAAJ,CAAoB,EAAEI,UAAUd,GAAZ,EAAiBe,KAAKd,CAAtB,EAAyBI,cAAzB,EAApB,CAhB0B;;AAAA;AAAA,gDAiB3BO,MAjB2B;;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA;AAAA,KAAxB;;AAAA;AAAA;AAAA;AAAA,MAAZ;AAmBA,SAAOZ,GAAP;AACD","file":"asyncArrayOf.js","sourcesContent":["// @flow\n\nimport { ValidationError } from \"../sync/ValidationError\";\nimport type { Errors } from \"../sync/ValidationError\";\nimport { arrayType } from \"../sync/arrayType\";\nimport { AsyncType } from \"./AsyncType\";\n\nexport class AsyncArrayOfType<T> extends AsyncType<Array<T>> {\n  innerType: AsyncType<T>;\n  constructor(t: AsyncType<T>, parse: (value: mixed) => Promise<Array<T>>) {\n    super(\"arrayOf\", parse);\n    this.innerType = t;\n  }\n}\n\nexport function asyncArrayOf<T>(t: AsyncType<T>): AsyncArrayOfType<T> {\n  const aof = new AsyncArrayOfType(t, async v => {\n    const a = arrayType.validate(v);\n    const errors: Errors = {};\n    const result: Array<T> = await Promise.all(\n      a.map(async (item, index) => {\n        try {\n          return await t.parse(item);\n        } catch (e) {\n          if (e instanceof ValidationError) {\n            errors[String(index)] = (e: ValidationError);\n            return (void 0: any);\n          } else throw e;\n        }\n      })\n    );\n    if (Object.getOwnPropertyNames(errors).length)\n      throw new ValidationError({ expected: aof, got: v, errors });\n    return result;\n  });\n  return aof;\n}\n"]}